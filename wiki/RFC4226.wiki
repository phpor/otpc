RFC4226的概要

= Introduction =
RFC4226记述的是HOTP，一个基于HMAC的动态口令的算法。由于本系统支持HOTP，在这里将介绍一下RFC4226的概要或者直接翻译一些章节。对于一些细节请参照<a href="http://www.ietf.org/rfc/rfc4226.txt">RFC 4226原文</a>。

= Details =

<pre>
4.算法的必要条件
   RFC4226的第四节，介绍了HOTP的算法设计要满足的主要的必要条件。重点强调了终端用户的使用
方便性，以及在可能提供最低限的用户界面的低端硬件上的实现能力。特别是具备嵌入到大量的SIM,
Java卡的能力是一个重要的前提。
   R1 - 这个算法必须是连续性的-或者基于事件：一个目的是把HOTP算法嵌入到大量的Java智能卡，USB 保护卡(dongles)和GSM SIM卡。
   R2 - 依靠最小化对电池，按钮数，计算能力和LCD界面尺寸的需求，这个算法应该能很经济的在
硬件上实现。
   R3 - 这个算法必须能利用到不支持任何数据输入的令牌(token),但也可能用在像Secure PIN-pads这样更加复杂的硬件上。
   R4 - 显示在令牌上的值必须便于用户读取和输入：这要求HOTP的值具有合理的长度。
   HOTP的值必须至少6位。为了方便在像手机这样的硬件上的输入，一个值得考虑的办法就是把HOTP
   的值设成只是数字。
   R5 - 必须具有用户友好的再同期计数器的机制。7.4节和附录E.4将详细介绍本资料建议的计数器
   再同期机制。
   R6 - 这个算法必须使用牢固的共享密码。共享密码必须至少128位。本资料推荐160的共享密码。

5.2 算法的概述
   HOTP算法是基于客户端和服务器端都知道下面两个值:
    C:一个递增的值，就好比一个计数器一样
     K:一个事先互相知道的值
    每次进行密码验证的时候，双方都利用下面的算法来生成一个动态的值      
       HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
</pre>  
  在这里HMAC-SHA-1指的是在<a href="http://www.ietf.org/rfc/rfc2104.txt">RFC2104</a>里定义的HASH算法。Truncate代表一个削减函数，以便把一个20位的HMAC-SHA-1算法的结果变成一个便于用户输入的值。（比如6位，8位）
<pre>   
</pre>