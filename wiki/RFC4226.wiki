RFC4226的概要

= Introduction =
RFC4226记述的是HOTP，一个基于HMAC的动态口令的算法。由于本系统支持HOTP，在这里将介绍一下RFC4226的概要或者直接翻译一些章节。对于一些细节请参照<a href="http://www.ietf.org/rfc/rfc4226.txt">RFC 4226原文</a>。

= Details =

<pre>
4.算法的必要条件
   RFC4226的第四节，介绍了HOTP的算法设计要满足的主要的必要条件。重点强调了终端用户的使用
方便性，以及在可能提供最低限的用户界面的低端硬件上的实现能力。特别是具备嵌入到大量的SIM,
Java卡的能力是一个重要的前提。
   R1 - 这个算法必须是连续性的-或者基于事件：一个目的是把HOTP算法嵌入到大量的Java智能卡，USB 保护卡(dongles)和GSM SIM卡。
   R2 - 依靠最小化对电池，按钮数，计算能力和LCD界面尺寸的需求，这个算法应该能很经济的在
硬件上实现。
   R3 - 这个算法必须能利用到不支持任何数据输入的令牌(token),但也可能用在像Secure PIN-pads这样更加复杂的硬件上。
   R4 - 显示在令牌上的值必须便于用户读取和输入：这要求HOTP的值具有合理的长度。
   HOTP的值必须至少6位。为了方便在像手机这样的硬件上的输入，一个值得考虑的办法就是把HOTP
   的值设成只是数字。
   R5 - 必须具有用户友好的再同期计数器的机制。7.4节和附录E.4将详细介绍本资料建议的计数器
   再同期机制。
   R6 - 这个算法必须使用牢固的共享密码。共享密码必须至少128位。本资料推荐160的共享密码。

5.2 算法的概述
   HOTP算法是基于客户端和服务器端都知道下面两个值:
    C:一个递增的值，就好比一个计数器一样
     K:一个事先互相知道的值
    每次进行密码验证的时候，双方都利用下面的算法来生成一个动态的值      
       HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
</pre>  
  在这里HMAC-SHA-1指的是在<a href="http://www.ietf.org/rfc/rfc2104.txt">RFC2104</a>里定义的HASH算法。Truncate代表一个削减函数，以便把一个20位的HMAC-SHA-1算法的结果变成一个便于用户输入的值。（比如6位，8位）
<pre>
5.3 生成HOTP值
   第1步：生成一个HMAC-SHA-1值,让HS = HMAC-SHA-1(K,C) //HS为20位的String
   
   第2步：生成一个4位的String(Dynamic Truncation,动态削减)
   让 Sbits = DT(HS)  //DT运算的定义参照下面说明，返回31-bit string

   第3步：计算HOTP值
   让 Snum  = StToNum(Sbits)   // 把S转化成一个0...2^{31}-1的数
   Return D = Snum mod 10^Digit //  D是一个位于0...10^{Digit}-1的数

   削减函数Truncate执行第2步和第3步处理。

   DT运算的定义
     DT(String)  //String = String[0]...String[19],HMAC-SHA-1运算的结果
     让 OffsetBits等于String[19]的低位4字节
     Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15
     让 P = String[OffSet]...String[OffSet+3]
     返回P的最后31字节
     
   在这里不使用P的最高位字节的目的是为了避免singed,unsigned代来的计算问题。
   不同的处理器对singed,unsigned的计算方式不一样，不使用最高位字节可以避免
   这样的问题。

5.4.  计算6位HOTP的例子（Digit = 6）
   下面的例子介绍怎样从HMAC-SHA-1运算结果抽取动态的二进制代码。
{{{
        //String[19]的低位4字节
        int offset   =  hmac_result[19] & 0xf ;
        //不使用最高位，利用 &0x7f
        int bin_code = (hmac_result[offset]  & 0x7f) << 24
           | (hmac_result[offset+1] & 0xff) << 16
           | (hmac_result[offset+2] & 0xff) <<  8
           | (hmac_result[offset+3] & 0xff) ;
}}}

   HMAC-SHA-1运算的例子

   -------------------------------------------------------------
   | Byte Number                                               |
   -------------------------------------------------------------
   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
   -------------------------------------------------------------
   | Byte Value                                                |
   -------------------------------------------------------------
   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
   -------------------------------***********----------------++|


   * 最后位的十六进制值是0x5a.
   * 低位四字节是0xa (offset 值).
   * offset 值为10 (0xa).
   * 从第十位开始的4位是 0x50ef7f19，这个就作为动态的二进制代码DBC1.
   * DBC1的最高位是 0x50，所以 DBC2 = DBC1 = 0x50ef7f19 = 135872921.
   * HOTP = DBC2 除以 10^6 的余 = 872921.

   这样用二进制代码135872921除以 1,000,000 (10^6) 的余就是一个6位的HOTP值。
   
</pre>