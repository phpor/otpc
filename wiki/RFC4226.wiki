RFC4226的概要

= Introduction =
RFC4226记述的是HOTP，一个基于HMAC的动态口令的算法。由于本系统支持HOTP，在这里将介绍一下RFC4226的概要或者直接翻译一些章节。对于一些细节请参照<a href="http://www.ietf.org/rfc/rfc4226.txt">RFC 4226原文</a>。

= Details =

<pre>
4.算法的必要条件
   RFC4226的第四节，介绍了HOTP的算法设计要满足的主要的必要条件。重点强调了终端用户的使用
方便性，以及在可能提供最低限的用户界面的低端硬件上的实现能力。特别是具备嵌入到大量的SIM,
Java卡的能力是一个重要的前提。
   `R1` - 这个算法必须是连续性的-或者基于事件：一个目的是把HOTP算法嵌入到大量的Java智能卡，USB 保护卡(dongles)和GSM SIM卡。
   `R2` - 依靠最小化对电池，按钮数，计算能力和LCD界面尺寸的需求，这个算法应该能很经济的在
硬件上实现。
   `R3` - 这个算法必须能利用到不支持任何数据输入的令牌(token),但也可能用在像Secure PIN-pads这样更加复杂的硬件上。
   `R4` - 显示在令牌上的值必须便于用户读取和输入：这要求HOTP的值具有合理的长度。
   HOTP的值必须至少6位。为了方便在像手机这样的硬件上的输入，一个值得考虑的办法就是把HOTP
   的值设成只是数字。
   `R5` - 必须具有用户友好的再同期计数器的机制。7.4节和附录E.4将详细介绍本资料建议的计数器
   再同期机制。
   `R6` - 这个算法必须使用牢固的共享密码。共享密码必须至少128位。本资料推荐160的共享密码。

5.2 算法的概述
   HOTP算法是基于客户端和服务器端都知道下面两个值:
    C:一个递增的值，就好比一个计数器一样
     K:一个共享的秘匙
    每次进行密码验证的时候，双方都利用下面的算法来生成一个动态的值      
       HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
</pre>  
  在这里HMAC-SHA-1指的是在<a href="http://www.ietf.org/rfc/rfc2104.txt">RFC2104</a>里定义的HASH算法。Truncate代表一个削减函数，以便把一个20位的HMAC-SHA-1算法的结果变成一个便于用户输入的值。（比如6位，8位）
<pre>
5.3 生成HOTP值
   第1步：生成一个HMAC-SHA-1值,让HS = HMAC-SHA-1(K,C) //HS为20位的String
   
   第2步：生成一个4位的String(Dynamic Truncation,动态削减)
   让 Sbits = DT(HS)  //DT运算的定义参照下面说明，返回31-bit string

   第3步：计算HOTP值
   让 Snum  = `StToNum`(Sbits)   // 把S转化成一个0...2^{31}-1的数
   Return D = Snum mod 10^Digit //  D是一个位于0...10^{Digit}-1的数

   削减函数Truncate执行第2步和第3步处理。


   DT运算的定义
{{{
     DT(String)  //String = String[0]...String[19],HMAC-SHA-1运算的结果
     让 OffsetBits等于String[19]的低位4字节
     Offset = StToNum(OffsetBits) // 0 <= OffSet <= 15
     让 P = String[OffSet]...String[OffSet+3]
}}}
     返回P的最后31字节
     
   在这里不使用P的最高位字节的目的是为了避免singed,unsigned代来的计算问题。
   不同的处理器对singed,unsigned的计算方式不一样，不使用最高位字节可以避免
   这样的问题。

5.4.  计算6位HOTP的例子（Digit = 6）
   下面的例子介绍怎样从HMAC-SHA-1运算结果抽取动态的二进制代码。
{{{
        //String[19]的低位4字节
        int offset   =  hmac_result[19] & 0xf ;
        //不使用最高位，利用 &0x7f
        int bin_code = (hmac_result[offset]  & 0x7f) << 24
           | (hmac_result[offset+1] & 0xff) << 16
           | (hmac_result[offset+2] & 0xff) <<  8
           | (hmac_result[offset+3] & 0xff) ;
}}}

   HMAC-SHA-1运算的例子

   -------------------------------------------------------------
   | Byte Number                                               |
   -------------------------------------------------------------
   |00|01|02|03|04|05|06|07|08|09|10|11|12|13|14|15|16|17|18|19|
   -------------------------------------------------------------
   | Byte Value                                                |
   -------------------------------------------------------------
   |1f|86|98|69|0e|02|ca|16|61|85|50|ef|7f|19|da|8e|94|5b|55|5a|
   -------------------------------***********----------------++|


   * 最后位的十六进制值是0x5a.
   * 低位四字节是0xa (offset 值).
   * offset 值为10 (0xa).
   * 从第十位开始的4位是 0x50ef7f19，这个就作为动态的二进制代码DBC1.
   * DBC1的最高位是 0x50，所以 DBC2 = DBC1 = 0x50ef7f19 = 135872921.
   * HOTP = DBC2 除以 10^6 的余 = 872921.

   这样用二进制代码135872921除以 1,000,000 (10^6) 的余就是一个6位的HOTP值。


7.2.  HOTP值的验证

   HOTP客户端(硬软件令牌)递增计数器的值，然后计算下一个HOTP值。如果认证服务器得到的值和
   客户端计算出来的值一样，那么HOTP值就被验证了。在这种情况下，服务器把计数器的值加1。

   如果认证服务器得到的值和客户端计算出来的值不一样，服务器在开始寻求另一个途径之前启动再同步
   的手续。(look-ahead window，即在接受一定范围内的超前的HOTP值，比如将计数器的值加1，
   加2，加3后的值)

   如果再同步失败，服务器然后要求协议的另一个认证途径发生，直到达到最大的允许探试次数。
   
   如果达到了最大的允许探试次数，服务器应该锁定账户并启动一个通知用户的手续。

7.4.  计数器的再同步

   虽然在一次成功的HOTP认证后才增加服务器计数器的值，在令牌上的计数器的值是只要用户请求
   一个新的HOTP就会被增加。因此，服务器上的计数器和令牌上的计数器的值就可能不同步。

   推荐在服务器上设置一个超前(look-ahead)变量s,让它来定义look-ahead window的大小。简单
   的说，就是服务器能计算接下来的s个服务器端HOTP值，然后用它们来检测接受接受到的HOTP客户端。

   在这种情况下，计数器的同步就仅仅是让服务器计算接下来的s个HOTP值并决定是否有一个一致的。
   作为一个选择，系统可以要求用户送连续的几个HOTP值(比如2个, 3个)以用来再同步，因为猜测连续
   的几个HOTP值比猜测单独的一个HOTP值要困难的多。

   变量s设置的上限确保服务器不会一直在检测HOTP值(导致denial-of-service攻击)并且限制攻击者
   可能的猜测范围。在确保不显著影响可用性的同时，s应当尽可能的小。
7.5. 共有秘匙的管理
   两个不同的生成和保存共有秘匙的办法:
   

      * Deterministic Generation: secrets are derived from a master
        seed, both at provisioning and verification stages and generated
        on-the-fly whenever it is required.
      * Random Generation: secrets are generated randomly at
        provisioning stage and must be stored immediately and kept
        secure during their life cycle.







M'Raihi, et al.              Informational                     [Page 11]

RFC 4226                     HOTP Algorithm                December 2005


   Deterministic Generation
   ------------------------

   A possible strategy is to derive the shared secrets from a master
   secret.  The master secret will be stored at the server only.  A
   tamper-resistant device MUST be used to store the master key and
   derive the shared secrets from the master key and some public
   information.  The main benefit would be to avoid the exposure of the
   shared secrets at any time and also avoid specific requirements on
   storage, since the shared secrets could be generated on-demand when
   needed at provisioning and validation time.

   We distinguish two different cases:

      - A single master key MK is used to derive the shared secrets;
        each HOTP device has a different secret, K_i = SHA-1 (MK,i)
        where i stands for a public piece of information that identifies
        uniquely the HOTP device such as a serial number, a token ID,
        etc.  Obviously, this is in the context of an application or
        service -- different application or service providers will have
        different secrets and settings.
      - Several master keys MK_i are used and each HOTP device stores a
        set of different derived secrets, {K_i,j = SHA-1(MK_i,j)} where
        j stands for a public piece of information identifying the
        device.  The idea would be to store ONLY the active master key
        at the validation server, in the Hardware Security Module (HSM),
        and keep in a safe place, using secret sharing methods such as
        [Shamir] for instance.  In this case, if a master secret MK_i is
        compromised, then it is possible to switch to another secret
        without replacing all the devices.

   The drawback in the deterministic case is that the exposure of the
   master secret would obviously enable an attacker to rebuild any
   shared secret based on correct public information.  The revocation of
   all secrets would be required, or switching to a new set of secrets
   in the case of multiple master keys.

   On the other hand, the device used to store the master key(s) and
   generate the shared secrets MUST be tamper resistant.  Furthermore,
   the HSM will not be exposed outside the security perimeter of the
   validation system, therefore reducing the risk of leakage.










M'Raihi, et al.              Informational                     [Page 12]

RFC 4226                     HOTP Algorithm                December 2005


   Random Generation
   -----------------

   The shared secrets are randomly generated.  We RECOMMEND following
   the recommendations in [RFC4086] and selecting a good and secure
   random source for generating these secrets.  A (true) random
   generator requires a naturally occurring source of randomness.
   Practically, there are two possible avenues to consider for the
   generation of the shared secrets:

      * Hardware-based generators: they exploit the randomness that
   occurs in physical phenomena.  A nice implementation can be based on
   oscillators and built in such ways that active attacks are more
   difficult to perform.

      * Software-based generators: designing a good software random
   generator is not an easy task.  A simple, but efficient,
   implementation should be based on various sources and apply to the
   sampled sequence a one-way function such as SHA-1.

   We RECOMMEND selecting proven products, being hardware or software
   generators, for the computation of shared secrets.

   We also RECOMMEND storing the shared secrets securely, and more
   specifically encrypting the shared secrets when stored using tamper-
   resistant hardware encryption and exposing them only when required:
   for example, the shared secret is decrypted when needed to verify an
   HOTP value, and re-encrypted immediately to limit exposure in the RAM
   for a short period of time.  The data store holding the shared
   secrets MUST be in a secure area, to avoid as much as possible direct
   attack on the validation system and secrets database.

   Particularly, access to the shared secrets should be limited to
   programs and processes required by the validation system only.  We
   will not elaborate on the different security mechanisms to put in
   place, but obviously, the protection of shared secrets is of the
   uttermost importance.


</pre>